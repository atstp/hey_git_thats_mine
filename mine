#!/usr/bin/env bash

git_root=$(git rev-parse --show-toplevel 2> /dev/null)
hg_root=$(hg root 2> /dev/null)

if [ ! -z "${git_root}" ]; then
  project_root=${git_root%%/}
elif [ ! -z "${hg_root}" ]; then
  project_root=${hg_root%%/}
else
  echo "you must be in a git or mercurial repo to use mine"; exit 1
fi

current_name=${project_root##*/}
mine_config=${MINE_LOCATION}/config

#support overriding default storage location
if [[ $MINE_STORAGE ]]; then
  snapshots_dir=$MINE_STORAGE
else
  snapshots_dir=${MINE_LOCATION}/snapshots
fi

project_backup=${snapshots_dir}/${current_name}

mine_dirpath(){
  for name in $@; do
    readlink -f $1 | sed "s!${project_root}/!!"
  done
}

mine_debug(){
sed 's/  //' <<VARDUMP
  global config variables for mine

     MINE_LOCATION=${MINE_LOCATION}
      MINE_STORAGE=${MINE_STORAGE}

  internal variables for mine

          git_root=${git_root}
           hg_root=${hg_root}
      current_name=${current_name}
      project_root=${project_root}
       mine_config=${mine_config}
     snapshots_dir=${snapshots_dir}
    project_backup=${project_backup}
VARDUMP
}

mine_snap(){ #HELPTEXT snapshot of the project's mine files
  local should_delete='' && [[ $1 == "-D" ]] \
                         && should_delete='--delete'

  rsync --quiet -vr \
        --filter="+ */" \
        --filter="+ **._mine**" \
        --filter="- *" \
        --prune-empty-dirs \
        ${should_delete:-""} \
        ${project_root}/ ${project_backup}/
};

mine_restore(){ #HELPTEXT restore the last project snapshot
  if [ -d "${project_backup}" ]; then
    rsync --quiet -vr \
          ${project_backup}/ ${project_root}/
  else
    echo "no backups found for ${current_name} at ${snapshots_dir}"
    exit 1
  fi
};

mine_clean(){ #HELPTEXT remove all ._mine files from the current repo without touching the snapshot
  find ${project_root} \
       -path '*._mine*' \
       -prune \
       -exec rm -rf '{}' \;
};

mine_purge(){ #HELPTEXT purge all mine files from the current project AND backups
  mine_list && printf "purge all ._mine files for ${current_name}? (y/n) "
  read yn
  if [[ "$yn" == "y" ]]; then
    rm -r ${project_backup}
    find ${project_root} -path '*._mine*' -exec rm -rf '{}' \;
  fi
};

mine_list(){ #HELPTEXT list all of the ._mine files in the project
  local files=$(find ${project_root} -path '*._mine*' | \
                sed -e "s!${project_root}/!!" -e 's/^/    /')
  printf "\n$(tput setaf 6)${files:-no mine files}$(tput sgr0)\n\n"
};

mine_touch_file(){
  local full=$1
  local ext=${full##*.}
  local name=${full%.*}
  touch ${name}._mine.${ext}
}

mine_touch(){ #HELPTEXT perhaps more natural than `touch <file>._mine`
  for name in $@; do mine_touch_file ${name}; done
};

mine_init(){ #HELPTEXT creates a `<projectname>._mine.md` file and a `notes._mine/` directory
  local newdir=${project_root}/notes._mine
  if [ ! -d "${newdir}" ]; then mkdir ${newdir} ; fi
  touch ${current_name}._mine.md \
        ${newdir}/{notes,todo}.md
};

mine_help(){
  hl=$(tput bold)
  norm=$(tput sgr0)
  echo
  printf "${hl}mine${norm} | manage your personal, project-related files in a versioned repo"
  echo
  echo
  sed -n \
      -e "${LINENO}q" \
      -e '/#HELPTEXT/{
            s!^[^_]\+_\([a-z]\+\)[^#]\+#HELPTEXT\(.*$\)!  \1\t\2!
            p
          }' \
      $0 \
  | column -t -s $'\t'
  echo
};

case $1 in
  help|touch|clean|purge|list|restore|snap|init) mine_"$1" "${@:2}" ;;
  debug) mine_debug ;;
  *) mine_help && exit 1;;
esac
